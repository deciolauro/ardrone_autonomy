#!/usr/bin/env python
import roslib; roslib.load_manifest('ardrone_autonomy')

import rospy
from ardrone_autonomy.msg import udp_proxy
'''
Bidirectional multi-client-server multi-port UDP proxy
Written by Mike Clement, March 2014

Relays traffic on a specified set of ports (see DEFAULT_PORTS)
between a set of clients by IP and corresponding servers by IP
(see IP_MAPPING).

The idea is to enable port-symmetric UDP communication between
a number of client application instances, each of which bind
their sockets to a specific (possibly loopback) IP address,
and a set of remote servers, one server for each client instance.
In reality, the clients and/or servers can be local or remote.

To test this using a local (loopback) client using (arbitrarily-
selected loopback IP 127.1.1.1) and a remote server using 
192.168.0.101, assuming the script is running on a device
having a server-facing interface with IP 192.168.0.123:

Client: nc -u -s 127.1.1.1 -p 5554 127.0.0.1 5554

Server: nc -u -l 5554

See variables and explanations below for more details.
'''

import sys
import select
import socket

# Tune this as needed so any UDP datagram can fit inside one recvfrom()
BUFSZ = 4096

	
# A list of all fileno's (used by select())
socket_list = []
opened_port_list = []

# Maps fileno's (used by select()) to the appropriate receiving
# and sending sockets
sock_mapping = {}



def handle_new_mapping(msg):
	from_ip = msg.from_ip
	from_port = int(msg.from_port)
	to_ip = msg.to_ip
	to_port = int(msg.to_port)
	
	# Create sockets (one per port, both for server-facing and client-facing)
	print("Building socket mapping for " + str(from_ip) + ":" + str(from_port) + " => " + str(to_ip) + ":" + str(to_port))
	
	if not from_port in opened_port_list:
		try:
			sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

			sock.bind(('0.0.0.0', from_port))
			socket_list.append(sock);
			opened_port_list.append(from_port)
			print "  Built socket for " + from_ip + ":" + str(from_port)

		except:
			print "Error building socket pair; exiting..."
			sys.exit(1)


	sock_mapping[(str(from_ip), from_port )] = (to_ip, to_port)
		
if __name__ == '__main__':
	rospy.init_node('udp_proxy_node')

	rospy.Subscriber("udp_proxy", udp_proxy, handle_new_mapping)

	portnum = -1
	while True:
		portnum += 1
		try:
			sending_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
			sending_sock.bind(('', portnum))
			opened_port = sending_sock.getsockname()[1]
			
			if opened_port <= 5550 or opened_port >= 5560:  # avoid conflicts with ardronelib
				break
			
			if portnum == 0:
				portnum = 6235
			sending_sock.shutdown()
			sending_sock.close()
		except:
			continue
	
	print("Opening port " + str(sending_sock.getsockname()[1]) + " for forwarding.")
	# Run the proxy
	while not rospy.is_shutdown():
		# Wait for a socket to have data ready to be read
		rready = []
		try:
			rready, wready, xready = select.select(socket_list, [], [], 0.1)
		except select.error as e:
			if e[0] == 4:  # keyboard interrupt
				print "Shutting down..."
				break
				
			print (e)
			print "Error during select(), continuing..."
			continue
		
		# Go through list of ready-to-read sockets
		for r in rready:
			try:
				# Receive the data
				data, source = r.recvfrom(BUFSZ)
				length = len(data)
				src_ip, src_port = source
				recv_port = r.getsockname()[1]
				
				# Do some sanity checks
				if not data:
					raise Exception("Null datagram, skipping...")
				if (src_ip, recv_port) not in sock_mapping:
					raise Exception("No match for src: " + str(src_ip) + ":" + str(recv_port) + " , skipping...")
				
				# Look up where this is destined and send it along
				(dst_ip, dst_port) = sock_mapping[(src_ip, recv_port)]
				sent = sending_sock.sendto(data, (dst_ip, dst_port))
				
				# Final sanity check
				if length != sent:
					raise Exception("Recv/Send length mismatch")
			except Exception as ex:
				print "  Error: " + ex.args[0]
				continue

	sending_sock.close()
	
	for sock in socket_list:
		sock.close()
